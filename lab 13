postgres=# CREATE TABLE employees (
postgres(#     employee_id SERIAL PRIMARY KEY,
postgres(#     first_name VARCHAR(50),
postgres(#     last_name VARCHAR(50),
postgres(#     department VARCHAR(50),
postgres(#     manager_id INT,
postgres(#     salary NUMERIC(10,2),
postgres(#     hire_date DATE,
postgres(#     tenure INT
postgres(# );
CREATE TABLE
postgres=# INSERT INTO employees (first_name, last_name, department, manager_id, salary, hire_date, tenure) VALUES
postgres-# ('Alice', 'Johnson', 'HR', NULL, 70000, '2018-03-12', 7),
postgres-# ('Bob', 'Smith', 'HR', 1, 55000, '2021-05-01', 4),
postgres-# ('Charlie', 'Brown', 'Finance', NULL, 90000, '2016-10-20', 9),
postgres-# ('David', 'Wilson', 'Finance', 3, 60000, '2020-01-15', 5),
postgres-# ('Eve', 'Miller', 'IT', NULL, 120000, '2015-07-07', 10),
postgres-# ('Frank', 'Lee', 'IT', 5, 80000, '2022-02-01', 3);
INSERT 0 6
postgres=# CREATE TABLE orders (
postgres(#     order_id SERIAL PRIMARY KEY,
postgres(#     region_id INT,
postgres(#     amount NUMERIC(10,2),
postgres(#     order_date DATE
postgres(# );
CREATE TABLE
postgres=# INSERT INTO orders (region_id, amount, order_date) VALUES
postgres-# (1, 1200, '2023-05-10'),
postgres-# (2, 900,  '2023-07-12'),
postgres-# (1, 2200, '2024-02-15'),
postgres-# (3, 1500, '2024-03-18'),
postgres-# (2, 700,  '2024-06-01');
INSERT 0 5
postgres=# CREATE TABLE sales (
postgres(#     product_name VARCHAR(100),
postgres(#     year INT,
postgres(#     sales_amount NUMERIC(10,2)
postgres(# );
CREATE TABLE
postgres=# INSERT INTO sales (product_name, year, sales_amount) VALUES
postgres-# ('Laptop', 2022, 30000),
postgres-# ('Laptop', 2023, 42000),
postgres-# ('Laptop', 2024, 50000),
postgres-# ('Phone', 2022, 15000),
postgres-# ('Phone', 2023, 22000),
postgres-# ('Phone', 2024, 28000),
postgres-# ('Tablet', 2023, 12000),
postgres-# ('Tablet', 2024, 16000);
INSERT 0 8
postgres=# CREATE TABLE warehouse_1 (
postgres(#     product_id SERIAL PRIMARY KEY,
postgres(#     product_name VARCHAR(50),
postgres(#     quantity INT
postgres(# );
CREATE TABLE
postgres=# CREATE TABLE warehouse_2 (
postgres(#     product_id SERIAL PRIMARY KEY,
postgres(#     product_name VARCHAR(50),
postgres(#     quantity INT
postgres(# );
CREATE TABLE
postgres=# INSERT INTO warehouse_1 (product_name, quantity) VALUES
postgres-# ('Laptop', 10),
postgres-# ('Phone', 5),
postgres-# ('Tablet', 0),
postgres-# ('Mouse', 7);
INSERT 0 4
postgres=# INSERT INTO warehouse_2 (product_name, quantity) VALUES
postgres-# ('Laptop', 8),
postgres-# ('Phone', 0),
postgres-# ('Tablet', 0),
postgres-# ('Keyboard', 4);
INSERT 0 4
postgres=# SELECT first_name, last_name, salary
postgres-# FROM employees
postgres-# WHERE salary > (
postgres(#     SELECT AVG(salary)  -- This scalar subquery returns a single value
postgres(#     FROM employees
postgres(# );
 first_name | last_name |  salary
------------+-----------+-----------
 Charlie    | Brown     |  90000.00
 Eve        | Miller    | 120000.00
 Frank      | Lee       |  80000.00
(3 rows)


postgres=# WITH regional_sales AS (
postgres(#     SELECT region_id, SUM(amount) AS total_sales
postgres(#     FROM orders
postgres(#     GROUP BY region_id
postgres(# )
postgres-# SELECT region_id, total_sales
postgres-# FROM regional_sales
postgres-# WHERE total_sales > 1000000;
 region_id | total_sales
-----------+-------------
(0 rows)


postgres=# WITH RECURSIVE cte_name AS (
postgres(#     -- Anchor member: The starting point
postgres(#     SELECT ... FROM ... WHERE ...
postgres(#     UNION ALL
postgres(#     -- Recursive member: References the CTE itself
postgres(#     SELECT ... FROM cte_name JOIN ... WHERE ...
postgres(# )
postgres-# SELECT * FROM cte_name;
ERROR:  character with byte sequence 0xd0 0x9e in encoding "UTF8" has no equivalent in encoding "WIN1252"
postgres=# WITH RECURSIVE org_chart AS (
postgres(#     -- Anchor: Find the top-level manager (e.g., who has no manager)
postgres(#     SELECT employee_id, first_name, last_name, manager_id
postgres(#     FROM employees
postgres(#     WHERE manager_id IS NULL
postgres(#     UNION ALL
postgres(#     -- Recursive: Find everyone who reports to the people already in the chart
postgres(#     SELECT e.employee_id, e.first_name, e.last_name, e.manager_id
postgres(#     FROM employees e
postgres(#     INNER JOIN org_chart oc ON e.manager_id = oc.employee_id
postgres(# )
postgres-# SELECT * FROM org_chart;
 employee_id | first_name | last_name | manager_id
-------------+------------+-----------+------------
           1 | Alice      | Johnson   |
           3 | Charlie    | Brown     |
           5 | Eve        | Miller    |
           2 | Bob        | Smith     |          1
           4 | David      | Wilson    |          3
           6 | Frank      | Lee       |          5
(6 rows)


postgres=# SELECT product_name FROM warehouse_1
postgres-# UNION
postgres-# SELECT product_name FROM warehouse_2;
 product_name
--------------
 Mouse
 Tablet
 Phone
 Laptop
 Keyboard
(5 rows)


postgres=# SELECT product_id FROM warehouse_1 WHERE quantity = 0
postgres-# INTERSECT
postgres-# SELECT product_id FROM warehouse_2 WHERE quantity = 0;
 product_id
------------
          3
(1 row)


postgres=# SELECT
postgres-#     first_name,
postgres-#     last_name,
postgres-#     department,
postgres-#     salary,
postgres-#     RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_salary_rank
postgres-# FROM employees;
 first_name | last_name | department |  salary   | dept_salary_rank
------------+-----------+------------+-----------+------------------
 Charlie    | Brown     | Finance    |  90000.00 |                1
 David      | Wilson    | Finance    |  60000.00 |                2
 Alice      | Johnson   | HR         |  70000.00 |                1
 Bob        | Smith     | HR         |  55000.00 |                2
 Eve        | Miller    | IT         | 120000.00 |                1
 Frank      | Lee       | IT         |  80000.00 |                2
(6 rows)


postgres=# SELECT
postgres-#     product_name,
postgres-#     SUM(CASE WHEN year = 2022 THEN sales_amount ELSE 0 END) AS year_2022,
postgres-#     SUM(CASE WHEN year = 2023 THEN sales_amount ELSE 0 END) AS year_2023,
postgres-#     SUM(CASE WHEN year = 2024 THEN sales_amount ELSE 0 END) AS year_2024
postgres-# FROM sales
postgres-# GROUP BY product_name;
 product_name | year_2022 | year_2023 | year_2024
--------------+-----------+-----------+-----------
 Tablet       |         0 |  12000.00 |  16000.00
 Phone        |  15000.00 |  22000.00 |  28000.00
 Laptop       |  30000.00 |  42000.00 |  50000.00
(3 rows)


postgres=# Unpivoting with UNION ALL:
postgres-# SELECT product_name, '2022' AS year, year_2022 AS sales_amount FROM pivoted_sales
postgres-# UNION ALL
postgres-# SELECT product_name, '2023' AS year, year_2023 AS sales_amount FROM pivoted_sales
postgres-# UNION ALL
postgres-# SELECT product_name, '2024' AS year, year_2024 AS sales_amount FROM pivoted_sales
postgres-# ORDER BY product_name, year;
ERROR:  character with byte sequence 0xd0 0x9e in encoding "UTF8" has no equivalent in encoding "WIN1252"
postgres=# SELECT product_name, '2022' AS year, year_2022 AS sales_amount FROM pivoted_sales
postgres-# UNION ALL
postgres-# SELECT product_name, '2023' AS year, year_2023 AS sales_amount FROM pivoted_sales
postgres-# UNION ALL
postgres-# SELECT product_name, '2024' AS year, year_2024 AS sales_amount FROM pivoted_sales
postgres-# ORDER BY product_name, year;
ERROR:  character with byte sequence 0xd0 0x9e in encoding "UTF8" has no equivalent in encoding "WIN1252"
postgres=# SELECT
postgres-#     employee_id,
postgres-#     SUM(salary) OVER (PARTITION BY department) AS total_dept_salary,
postgres-#     AVG(salary) FILTER (WHERE tenure > 5) OVER () AS avg_salary_senior
postgres-# FROM employees;
 employee_id | total_dept_salary | avg_salary_senior
-------------+-------------------+--------------------
           3 |         150000.00 | 93333.333333333333
           4 |         150000.00 | 93333.333333333333
           1 |         125000.00 | 93333.333333333333
           2 |         125000.00 | 93333.333333333333
           5 |         200000.00 | 93333.333333333333
           6 |         200000.00 | 93333.333333333333
(6 rows)


postgres=# SELECT product_name, status
postgres-# FROM orders
postgres-# ORDER BY
postgres-#     CASE status
postgres-#         WHEN 'High Priority' THEN 1
postgres-#         WHEN 'Medium Priority' THEN 2
postgres-#         WHEN 'Low Priority' THEN 3
postgres-#         ELSE 4
postgres-#     END;
ERROR:  character with byte sequence 0xd0 0x9e in encoding "UTF8" has no equivalent in encoding "WIN1252"
postgres=#
